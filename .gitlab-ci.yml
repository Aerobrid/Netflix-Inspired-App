# Default image to be used within the jobs (can be overriden within jobs)
# Used Debian Bullseye Node image so OpenSSL 1.1 (libcrypto.so.1.1) is available (gitlab CI would not work without)
image: node:18-bullseye

stages:
  - build
  - publish
  - deploy

variables:
  NODE_ENV: production

  NPM_CONFIG_PRODUCTION: "false"

cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - frontend/node_modules/
    - node_modules/

build:
  stage: build
  image: node:18-bullseye
  script:
    - echo "Installing frontend dependencies"
    - npm ci --prefix frontend --include=dev
    - echo "Installing root dependencies"
    - npm ci --include=dev
    - echo "Building App"
    - npm run build
    - echo "Running tests"
    - npm test --silent
  artifacts:
    paths:
      - build/
      - dist/
    expire_in: 1 day
  # on push to main or PR (MR in gitlab)
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"'
      when: always
    - when: never

publish-image:
  stage: publish
  # docker inside of docker!
  image: docker:24
  # the job needs to talk to DinD daemon
  services:
    - name: docker:24-dind
      alias: dind
  variables:
    # disable TLS cert handling to make communication easier
    DOCKER_TLS_CERTDIR: ""
    IMAGE: "ghcr.io/${GHCR_USERNAME}/${CI_PROJECT_NAME_LOWER}:${CI_COMMIT_SHA}"
  needs:
    - job: build
      artifacts: false
  # only on push to main
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
      when: on_success
    - when: never
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
  script:
    - docker build -t "$IMAGE" .
    - docker push "$IMAGE"
  after_script:
    - docker logout ghcr.io || true
    - rm -f /root/.docker/config.json || true

deploy:
  stage: deploy
  image: alpine:3.18
  needs:
    - job: publish-image
      artifacts: false
  variables:
    IMAGE: "ghcr.io/${GHCR_USERNAME}/${CI_PROJECT_NAME_LOWER}:${CI_COMMIT_SHA}"
  before_script:
    - apk add --no-cache openssh-client bash
    - mkdir -p ~/.ssh
    - |
      if [ -f "$SSH_KEY" ]; then
        cp "$SSH_KEY" ~/.ssh/id_rsa
      else
        printf '%s' "$SSH_KEY" > ~/.ssh/id_rsa
      fi
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H "$DO_SERVER_IP" >> ~/.ssh/known_hosts || true
  # create env file from CI vars, copy to Droplet, remove old container/image, run new container on port 5000
  script:
    - |
      printf '%s
    ' "PORT=${PORT}" "NODE_ENV=${NODE_ENV}" "MONGO_URI=${MONGO_URI}" "JWT_SECRET=${JWT_SECRET}" "TMDB_API_KEY=${TMDB_API_KEY}" > app.env
      chmod 600 app.env
      scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -P ${DO_SSH_PORT:-22} app.env ${DO_SSH_USER}@${DO_SERVER_IP}:/tmp/app.env
      rm -f app.env
      ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p ${DO_SSH_PORT:-22} ${DO_SSH_USER}@${DO_SERVER_IP} "docker pull ${IMAGE} && docker stop app || true && docker rm app || true && docker run -d --name app --env-file /tmp/app.env -p 5000:5000 ${IMAGE} && rm -f /tmp/app.env && docker image prune -af"
  after_script:
    - rm -f ~/.ssh/id_rsa || true
    - rm -f app.env || true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
      when: on_success
    - when: never
